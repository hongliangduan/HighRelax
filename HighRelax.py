# -*- coding: utf-8 -*-
# ======================================================
# Compatibility Patch: Faking numpy.compat for compatibility
# with ParmEd on newer versions of numpy
# ======================================================
import sys, types

# Create a fake numpy.compat module
compat_module = types.ModuleType("numpy.compat")

# Define compatibility functions
def _asbytes(s):
    if isinstance(s, (bytes, bytearray)):
        return bytes(s)
    return str(s).encode("latin1")

def _asstr(s):
    if isinstance(s, (bytes, bytearray)):
        return bytes(s).decode("latin1")
    return str(s)

# Assign functions to the fake compat module
compat_module.asbytes = _asbytes
compat_module.asstr = _asstr

# Register the fake module with sys.modules
sys.modules["numpy.compat"] = compat_module

# ======================================================
# Regular Imports
# ======================================================
import numpy as np
from openmm import *
from openmm.app import *
from openmm.unit import *
from parmed import load_file

# ======================================================
# Input Files
# ======================================================
PRMTOP_FILE = "system.prmtop"
INPCRD_FILE = "system.inpcrd"
REF_PDB_FILE = "c.pdb"  # PDB file generated by tleap (contains TER for chain separation)

# ======================================================
# Load Amber Topology and Coordinates
# ======================================================
prmtop = load_file(PRMTOP_FILE)         # ParmEd Structure
inpcrd = AmberInpcrdFile(INPCRD_FILE)   # OpenMM AmberInpcrdFile
ref_pdb = PDBFile(REF_PDB_FILE)

# ======================================================
# Relaxation Parameters
# ======================================================
unnatural_resnames = [
    "0A1", "0AF", "0BN", "2AG", "2AS", "2FM", "2HF", "2NP", "3CF", "3FG", "3GL", "3MY", "004",
    "4BF", "4CF", "4CY", "4FW", "4HT", "4IN", "4PH", "6CL", "6CW", "26P", "32T", "200",
    "AA4", "ABA", "ACZ", "AGM", "AHB", "AHP", "ALC", "ALN", "ALO", "APD", "APM", "ARO", "AS2",
    "BB8", "BCS", "BHD", "BIF", "BIU", "BTR", "BUG", "C2N", "CAN", "CCS", "CHG", "CHP", "CIR",
    "CSA", "CSE", "CTE", "CTH", "D4P", "DAB", "DAH", "DBY", "DDZ", "DMK", "DPP", "ESC", "F2F",
    "FCL", "FGL", "FLA", "FT6", "FTR", "GGB", "GHG", "GME", "HCS", "HGA", "HHK", "HL2", "HLU",
    "HOX", "HPE", "HQA", "HRG", "HRP", "HTR", "HVA", "I2M", "IGL", "IIL", "ILX", "IYR", "KYN",
    "LDO", "LE1", "LED", "LEF", "LME", "LMQ", "LVG", "LVN", "M2S", "ME0", "MEG", "MEN", "MEQ",
    "MHO", "MTY", "NAL", "NIY", "NLE", "NVA", "OAS", "OBF", "OCY", "OLT", "OMT", "OMX", "OMY",
    "ONL", "ORN", "PBF", "PF5", "PFF", "PHI", "PPN", "PTR", "SEP", "SLZ", "SME", "SYM", "TH6",
    "TIH", "TPO", "TRO", "TRP", "TRX", "TTQ", "TY2", "TYI", "TYQ", "TYR", "UN1", "VAH", "WFP",
    "YCM", "YOF", "2MR", "AIB", "ALY", "CSO", "DA2", "DLE", "DPR", "HYP", "M3L", "MLY", "MLZ",
    "MSE", "PCA", "PRK", "AHP", "IML", "TYS", "DAL", "DAR", "DAS", "DCY", "DGL", "DGN", "DHI",
    "DIL", "DLE", "DLY", "DPN", "DPR", "DSG", "DSN", "DTH", "DTR", "DTY", "DVA", "MED"
]

relax_radius = 1
FORCE_TOL = 2.39 * kilojoule_per_mole / nanometer   # Consistent with AF2 code
INNER_MAX_ITERS = 1000
STIFFNESS = [500.0, 250.0, 100.0]  # kcal/mol/Å² (gradually reduced)

# ======================================================
# Build OpenMM System
# ======================================================
if inpcrd.boxVectors is None:
    print("⚠ No box vectors, treating system as non-periodic.")
    system = prmtop.createSystem(nonbondedMethod=NoCutoff, constraints=HBonds)
else:
    system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1.2*nanometer, constraints=HBonds)

integrator = LangevinMiddleIntegrator(300*kelvin, 1/picosecond, 0.002*picoseconds)
simulation = Simulation(prmtop.topology, system, integrator)
simulation.context.setPositions(inpcrd.positions)

print("\nInitial potential energy:")
print(simulation.context.getState(getEnergy=True).getPotentialEnergy())

# ======================================================
# Identify unAA ±1 Residues
# ======================================================
residues = list(prmtop.residues)
target_res_indices = set()
for i, res in enumerate(residues):
    if res.name in unnatural_resnames:
        for offset in range(-relax_radius, relax_radius+1):
            j = i + offset
            if 0 <= j < len(residues):
                target_res_indices.add(j)

def _rmsd_nm(p1, p2):
    a = np.array([[v.x, v.y, v.z] for v in p1])
    b = np.array([[v.x, v.y, v.z] for v in p2])
    return float(np.sqrt(((a - b)**2).mean()))

# ======================================================
# Stage 1: Local Relax (freeze non-target residues)
# ======================================================
print("\nStage 1: Local relax (freeze non-target residues)")
restraint1 = CustomExternalForce("0.5*k*((x-x0)^2+(y-y0)^2+(z-z0)^2)")
restraint1.addPerParticleParameter("x0")
restraint1.addPerParticleParameter("y0")
restraint1.addPerParticleParameter("z0")
restraint1.addGlobalParameter("k", 2000.0)

positions = simulation.context.getState(getPositions=True).getPositions()
for i, atom in enumerate(prmtop.topology.atoms()):
    res = residues[atom.residue.index]
    if res.idx not in target_res_indices:
        pos = positions[i]
        restraint1.addParticle(i, [pos.x, pos.y, pos.z])

system.addForce(restraint1)
simulation.context.reinitialize(preserveState=True)

simulation.minimizeEnergy(tolerance=FORCE_TOL, maxIterations=INNER_MAX_ITERS)
st = simulation.context.getState(getPositions=True, getEnergy=True)
positions = st.getPositions()
print(f"   Energy = {st.getPotentialEnergy()}, RMSD = {_rmsd_nm(positions, st.getPositions())*10:.3f} Å")

# ======================================================
# Stage 2: Global Relax (gradual backbone restraint)
# ======================================================
for stage, k_val in enumerate(STIFFNESS, 1):
    print(f"\nStage 2.{stage}: Global relax (backbone restraint k={k_val})")

    # Remove old restraints
    while system.getNumForces() > 0 and isinstance(system.getForce(system.getNumForces()-1), CustomExternalForce):
        system.removeForce(system.getNumForces()-1)

    # Add new backbone restraint
    restraint = CustomExternalForce("0.5*k*((x-x0)^2+(y-y0)^2+(z-z0)^2)")
    restraint.addPerParticleParameter("x0")
    restraint.addPerParticleParameter("y0")
    restraint.addPerParticleParameter("z0")
    restraint.addGlobalParameter("k", k_val * kilocalorie_per_mole / angstrom**2)

    for i, atom in enumerate(prmtop.topology.atoms()):
        if atom.name in ("N", "CA", "C", "O"):
            pos = positions[i]
            restraint.addParticle(i, [pos.x, pos.y, pos.z])
    system.addForce(restraint)

    integrator2 = LangevinMiddleIntegrator(300*kelvin, 1/picosecond, 0.002*picoseconds)
    simulation = Simulation(prmtop.topology, system, integrator2)
    simulation.context.setPositions(positions)

    simulation.minimizeEnergy(tolerance=FORCE_TOL, maxIterations=INNER_MAX_ITERS)
    st = simulation.context.getState(getPositions=True, getEnergy=True)
    positions = st.getPositions()
    print(f"   Energy = {st.getPotentialEnergy()}")

# ======================================================
# Output: Hydrogenated & Dehydrogenated Versions (multi-chain preserved)
# ======================================================
with open("relaxed_final.pdb", "w") as f:
    PDBFile.writeFile(ref_pdb.topology, positions, f)

with open("relaxed_final.pdb") as fin, open("relaxed_final_noH.pdb", "w") as fout:
    for line in fin:
        if line.startswith(("ATOM", "HETATM")):
            atom_name = line[12:16].strip()
            element = line[76:78].strip()
            if atom_name.startswith("H") or element == "H":
                continue
        fout.write(line)

print("✅ Done →")
print("   relaxed_final.pdb      (with H, multi-chain)")
print("   relaxed_final_noH.pdb  (no H, multi-chain)")
